# Fix Flutter Web `Failed to fetch` for manifest requests

## What is happening now
- `example/lib/main.dart` creates `OtaLocalizationController` and calls `initialize()`, which triggers `checkForUpdates()`.
- `lib/src/controller/ota_localization_controller.dart` builds manifest URL as `https://rerune.io/api/sdk/projects/{projectId}/translations/manifest?platform=flutter` and sends auth headers via `_authHeaders()`.
- `lib/src/network/manifest_client.dart` performs `http.Client.get` with `Accept`, optional `If-None-Match`, and `X-API-Key`.
- On Flutter Web, browser networking rules apply; `ClientException: Failed to fetch` indicates request blocked before an HTTP response is exposed (most likely CORS/preflight policy failure).

## Recommended implementation
1. Improve SDK diagnostics for web fetch failures (no breaking API changes).
   - Add optional context fields to `OtaError` so callers can inspect operation/URL/hint while preserving existing fields.
   - In `OtaLocalizationController.checkForUpdates()`, centralize network error creation into a helper that:
     - Detects likely web CORS failure (`kIsWeb` + `Failed to fetch`/browser-style transport errors).
     - Adds a targeted hint describing required backend CORS headers.
     - Attaches request URI and operation (`manifest` or `arb`).
2. Keep request behavior unchanged by default.
   - Do not change auth mechanism (`X-API-Key`) or ETag behavior in this pass, to avoid compatibility/security side effects.
3. Document the required backend CORS contract and troubleshooting steps.
   - Add explicit web section in docs with preflight requirements for manifest and ARB endpoints.
   - Include required headers/methods and `ETag` exposure guidance.
4. Make the example app surface update errors to developers.
   - Show last update error summary in UI after `checkForUpdates()` (not just console output), so web failures are visible immediately.
5. Add tests for new diagnostics behavior.
   - Unit tests validating that web-like transport errors produce enriched `OtaError` hints/context.
   - Preserve existing behavior for non-web or non-CORS failures.

## Files to modify
- `lib/src/model/ota_error.dart`
- `lib/src/controller/ota_localization_controller.dart`
- `lib/src/network/manifest_client.dart` (only if needed to improve operation/URL context)
- `lib/src/network/arb_client.dart` (only if needed to improve operation/URL context)
- `README.md`
- `example/README.md`
- `example/lib/main.dart`
- `test/` (new/updated tests for diagnostics)

## Backend contract to confirm (outside this repo)
- `OPTIONS` enabled for:
  - `/api/sdk/projects/{projectId}/translations/manifest`
  - `/api/sdk/projects/{projectId}/translations/{platform}/{locale}`
- `Access-Control-Allow-Origin` includes the web app origin.
- `Access-Control-Allow-Methods` includes `GET, OPTIONS`.
- `Access-Control-Allow-Headers` includes `X-API-Key, If-None-Match, Accept`.
- `Access-Control-Expose-Headers` includes `ETag`.
- `Vary` includes `Origin, Access-Control-Request-Method, Access-Control-Request-Headers`.

## Verification
1. Automated
   - Run package tests: `flutter test`
   - Run web-targeted tests where applicable: `flutter test --platform chrome`
2. Example app runtime
   - Start example on web: `flutter run -d chrome` from `example/`.
   - Confirm manifest request succeeds when backend CORS is correct.
   - Temporarily simulate/observe CORS failure and confirm enriched SDK error includes actionable hint and URL.
3. Regression checks
   - Verify Android/iOS/macOS behavior unchanged (no new failures, same update flow).
   - Verify manifest/ARB success path and ETag caching still function as before.

## Execution order
1. Implement `OtaError` context + controller error helper.
2. Update docs with web CORS requirements.
3. Update example UI to show update errors.
4. Add/adjust tests.
5. Run verification commands and finalize.
